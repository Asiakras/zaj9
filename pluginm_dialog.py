# -*- coding: utf-8 -*-
"""
Created on Sun Jun  9 20:53:38 2024

@author: Paweł
"""

# -*- coding: utf-8 -*-
"""
/***************************************************************************
 pluginmDialog
                                 A QGIS plugin
 pluginm
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2024-06-03
        git sha              : $Format:%H$
        copyright            : (C) 2024 by joanna krasnodebska
        email                : jhdb
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os

from qgis.PyQt import uic
from qgis.PyQt import QtWidgets
from qgis.utils import iface
from qgis.core import QgsWkbTypes
from qgis.core import QgsMessageLog, Qgis
import numpy as np
from qgis.core import QgsProject, QgsPointXY


# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'pluginm_dialog_base.ui'))


class pluginmDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, parent=None):
        """Constructor."""
        super(pluginmDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)
        self.pushButton_zliczobiek.clicked.connect(self.zlicz_obiekty)
        self.pushButton_pokazwsp.clicked.connect(self.podaj_dane_o_obiekcie)
        self.pushButton_dh.clicked.connect(self.calculate_dh)
        self.pushButton_liczpole.clicked.connect(self.licz_pole)

    def zlicz_obiekty(self):
        wybrana_warstwa =  self.mMapLayerComboBox.currentLayer()
        liczba_obiektów = wybrana_warstwa.featureCount()
        self.labelWynik.setText(str(liczba_obiektów))
    
    def podaj_dane_o_obiekcie(self):
        aktywna_warstwa = iface.activeLayer()
        selected_f = aktywna_warstwa.selectedFeatures()
        self.label_resultnazwa.setText(aktywna_warstwa.name())
        self.listaWybranychOb_wsp.clear()  # Wyczyszczenie listy przed dodaniem nowych wartości
        for feature in selected_f:
            geom = feature.geometry()
            geomSingleType = QgsWkbTypes.isSingleType(geom.wkbType())
            if geom.type() == QgsWkbTypes.PointGeometry:
                if geomSingleType:
                    point = geom.asPoint()
                    x, y = round(point.x(), 3), round(point.y(), 3)
                    self.listaWybranychOb_wsp.append(f'Point: ({x}, {y}) \r\n')
                else:
                    points = geom.asMultiPoint()
                    points_str = ', '.join([f'({round(p.x(), 3)}, {round(p.y(), 3)})' for p in points])
                    self.listaWybranychOb_wsp.append(f'MultiPoint: {points_str} \r\n')
            elif geom.type() == QgsWkbTypes.LineGeometry:
                if geomSingleType:
                    line = geom.asPolyline()
                    line_str = ', '.join([f'({round(p.x(), 3)}, {round(p.y(), 3)})' for p in line])
                    self.listaWybranychOb_wsp.append(f'Line: {line_str} \r\n')
                else:
                    lines = geom.asMultiPolyline()
                    lines_str = '; '.join([', '.join([f'({round(p.x(), 3)}, {round(p.y(), 3)})' for p in line]) for line in lines])
                    self.listaWybranychOb_wsp.append(f'MultiLine: {lines_str} \r\n')
            elif geom.type() == QgsWkbTypes.PolygonGeometry:
                if geomSingleType:
                    polygon = geom.asPolygon()
                    polygon_str = '; '.join([', '.join([f'({round(p.x(), 3)}, {round(p.y(), 3)})' for p in ring]) for ring in polygon])
                    self.listaWybranychOb_wsp.append(f'Polygon: {polygon_str} \r\n')
                else:
                    polygons = geom.asMultiPolygon()
                    polygons_str = ' | '.join(['; '.join([', '.join([f'({round(p.x(), 3)}, {round(p.y(), 3)})' for p in ring]) for ring in polygon]) for polygon in polygons])
                    self.listaWybranychOb_wsp.append(f'MultiPolygon: {polygons_str} \r\n')
            else:
                self.listaWybranychOb_wsp.append('Nieznana lub nieprawidłowa geometria\r\n')
                    
        
    def calculate_dh(self):
        current_layer = self.mMapLayerComboBox.currentLayer()
        if current_layer is None:
            iface.messageBar().pushMessage("Różnica wysokosci", 'Nie wybrano aktywnej warstwy', level = Qgis.Warning)
            return
        selected_features = current_layer.selectedFeatures()
        if len(selected_features) != 2:
            iface.messageBar().pushMessage("Różnica wysokosci", 'Aby policzyć dh wybierz DWA PUNKTY', level = Qgis.Warning)
            return
        if len(selected_features) == 2:
            h_1 = float(selected_features[0]['wysokosc'])
            h_2 = float(selected_features[1]['wysokosc'])
            d_h = round(h_2 - h_1, 3)
            self.label_dh_result.setText(f'{d_h} m')
            
        QgsMessageLog.logMessage('Różnica wysokości między wybranymi punktami wynosi:' +str(d_h) +'m', level = Qgis.Success)
        
        iface.messageBar().pushMessage("Różnica wysokosci",'Różnica wysokości między wybranymi punktami wynosi:' +str(d_h) +'m', level = Qgis.Success)
        
    
    def licz_pole(self):
        obiekty = self.mMapLayerComboBox.currentLayer().selectedFeatures()
        punkty = []
        for o in obiekty:
            x = float(o.geometry().asPoint().x())
            y = float(o.geometry().asPoint().y())
            p = QgsPointXY(x, y)
            punkty.append(p)
            
        if len(punkty) < 3:
            iface.messageBar().pushMessage("Pole powierzchni", 'Aby policzyć pole powierzchni wybierz co najmniej TRZY PUNKTY', level=Qgis.Warning)
            return
            
        if len(punkty) > 2:
            pole = 0
            dl = len(punkty)
            for e in range(dl):
                a = (e + 1) % dl
                pole += (punkty[a].x() + punkty[e].x()) * (punkty[a].y() - punkty[e].y())

            pole /= 2
            pole = round(abs(pole / 10000), 3)
            
         
            self.label_pole.setText(str(pole) + ' ha')

        QgsMessageLog.logMessage('Pole powierzchni wielokąta wynosi: ' + str(pole) + ' ha', level = Qgis.Success)
        
        iface.messageBar().pushMessage("Pole powierzchni", 'Pole powierzchni wielokąta wynosi: ' + str(pole) + ' ha', level = Qgis.Success)
       
        
    #def oblicz_powierzchnie(wspolrzedne):
   
    #n = len(wspolrzedne)
    ##if n < 3:
        #raise ValueError("Wielokąt musi mieć przynajmniej 3 wierzchołki")
    
    #suma = 0.0
    #for i in range(n):
        #x1, y1 = wspolrzedne[i]
        #x2, y2 = wspolrzedne[(i + 1) % n]  # Zapewnia, że ostatni wierzchołek łączy się z pierwszym
        #suma += x1 * y2 - y1 * x2

    #return abs(suma) / 2.0